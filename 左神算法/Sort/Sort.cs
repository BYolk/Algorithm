using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
/*排序算法的稳定性及其汇总：
 *  1、同样值的个体之间，如果不因为排序而改变相对次序，就说这个排序是有稳定性的，否则就没有
 *  2、不具备稳定性的排序：
 *      1、选择排序
 *      2、快速排序
 *      3、堆排序
 *  3、具备稳定性的排序：
 *      1、冒泡排序
 *      2、插入排序
 *      3、归并排序
 *      4、一切桶排序思想下的排序
 *      
 *  4、存在问题：目前没有找到时间复杂度 O(N * logN)，额外空间复杂度为 O(1),又稳定的排序
 *  
 *  5、总结：
 *      排序类型    时间复杂度   空间复杂度   稳定性
 *      选择排序    O(N^2)      O(1)        无
 *      冒泡排序    O(N^2)      O(1)        有
 *      插入排序    O(N^2)      O(1)        有
 *      归并排序    O(N * logN) O(N)        有    
 *      快速排序    O(N * logN) O(logN)     无    
 *      堆排序      O(N * logN) O(1)        无    
 *      
 *  6、选择：
 *      1、在选择上，通过实验得出的结论是：使用快速排序是最快的
 *      2、如果空间有限制，就是用堆排序
 *      3、如果考虑稳定性，则选择归并排序
 *      
 *  7、问题：
 *      1、基于比较的问题，时间复杂度能否在 N * logN 以下？
 *          ————目前还未找到，也就是不行
 *      2、在时间复杂度为 N * logN 的前提下，让空间复杂度小于 O(N) 并且让其做到稳定性
 *          ————目前还未找到，也就是不行
 *          
 *  8、基于以上问题，注意常见的坑：
 *      1、归并排序的额外空间复杂度可以变为 O(1),但是非常难，而且变完后不再有序（还不如直接用堆排序），不需要掌握，感兴趣可以搜“归并排序 内部缓存法”
 *      2、“原地归并排序” 的帖子都是垃圾，会让归并排序的时间复杂度变成 O(N^2)
 *      3、快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜“01 stable sort”
 *      4、所有的改进都不重要，因为目前没有找到时间复杂度 O(N * logN),额外空间复杂度 O(1)，又稳定的排序
 *      5、有一道题目，奇数放在数组左边，偶数放在数组右边，还要求原始相对次序不变，碰到这个问题，可以怼面试官
 *          ————这个问题是一个“01”问题，也就是“True/False”问题，我们可以用快速排序 partition 进行区分，要让快速排序做到稳定性的，需要使用论文级别的算法 “01 stable sort”，所以这道题可以解，但是非常难。
 *          
 *  9、工程上的排序：
 *      1、充分利用 O(N * logN) 和 O(N^2) 排序各自的优势
 *      2、稳定性的考虑
 *      
 *  10、补充：
 *      1、二分法————>时间复杂度为 log2N，在计算机中，以2为底的对数2会省略不写，如logN
 *          1、在一个有序数组中，找某数是否存在
 *          2、在一个有序数组中，找 >= 某个数最左侧的位置（排好序的数组中会存在相同的数字，找最左侧的那一个，则将二分进行到底，进行到某个范围没有该数的时候结束）
 *          3、局部最小值问题（不是有序才二分，无序也是可以二分的）
 *          
 *          
 *      2、master 公式 :T(N) = a * T(N/b) + O(N^d)——————用于求解递归时间复杂度（跟很多东西都有关）
 *          1、T(N) 表示母问题规模量为 N
 *          2、T(N/b) 表示子问题规模都为 N/b，注意是都为，规模都是一样的
 *          3、a 表示子问题被调用的次数
 *          4、O(N^d) 除调用之外的其它过程的时间复杂度
 *          5、master 公式满足以下结论：
 *              1、log(b,a) > d ——> 复杂度为 O(N^log(b,a))
 *              2、log(b,a) = d ——> 复杂度为 O(N^d * logN)
 *              3、log(b,a) < d ——> 复杂度为 O(N^d)
*/


namespace 算法.Sort
{
    internal class Sort
    {



    }
}
