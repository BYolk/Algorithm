using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 算法.Tree
{
    internal class Tree
    {
        ///
        ///树结构：
        /// 1、二叉树结点结构：
        ///     class Node<V>{
        ///         V value;    //结点的值
        ///         Node left;  //结点的左孩子
        ///         Node right; //结点的右孩子
        ///     }
        /// 2、递归方式实现二叉树的遍历：
        ///     1、递归序：每个结点都会被访问三次的顺序叫递归序,在递归序的基础上,可以加工出三种遍历方式：先序、中序、后序遍历
        ///         public static void RecursiveTraversal(Node head){
        ///             //进入本方法————第一次来到该节点处
        ///             if(head == null)
        ///                 return;  
        ///             
        ///             RecursiveTraversal(left);
        ///             //遍历完左孩子之后回到本方法————第二次来到该结点处
        ///             
        ///             RecursiveTraversal(right);
        ///             //遍历完右孩子之后回到本方法————第三次来到该结点处
        ///             
        /// 
        ///             //每个结点都会被访问三次的顺序叫递归序
        ///         }
        ///     2、先序遍历：
        ///         1、对于每一个子树，都先打印头结点，然后打印左节点，最后打印右节点，这样的遍历叫先序遍历
        ///         2、和递归序有什么关系？
        ///             ————当第一次来到该结点的时候，打印该结点，第二三次来到该结点的时候不管，这样的递归序就是先序遍历
        ///     3、中序遍历：
        ///         1、对于每一个子树，都先打印左结点，然后打印头节点，最后打印右节点，这样的遍历叫中序遍历
        ///         2、和递归序有什么关系？
        ///             ————当第二次来到该结点的时候，打印该结点，第一三次来到该节点的时候不管，这样的递归序就是中序遍历
        ///     4、后序遍历：
        ///         1、对于每一个子树，都先打印左结点，然后打印右节点，最后打印头节点，这样的遍历叫后序遍历
        ///         2、和递归序有什么关系？
        ///             ————当第三次来到该结点的时候，打印该结点，第一二次来到该节点的时候不管，这样的递归序就是后序遍历
        /// 3、非递归方式实现二叉树的遍历：
        ///     0、任何递归都可以改称非递归（无非就是系统压栈变成我们手动压栈）
        ///     1、具体实现见 Traversal（遍历） 类
        /// 4、如何直观打印一颗二叉树（不管）
        /// 5、如何完成二叉树宽度优先遍历（常见题目：求二叉树宽度）

        #region 树的结构：
        public class TreeNode
        {
            public int value;
            public TreeNode left;
            public TreeNode right;
            public TreeNode(int value)
            {
                this.value = value;
            }
        }
        #endregion

        ///二叉树的相关概念及其实现判断
        /// 1、如何判断一颗二叉树是否是搜索二叉树
        /// 2、如何判断一颗二叉树是完全二叉树
        /// 3、如何判断一颗二叉树是满二叉树
        /// 4、如何判断一颗二叉树是平衡二叉树（二叉树题目套路）

        ///如何判断一颗二叉树是否是搜索二叉树：
        /// 1、什么是搜索二叉树：
        ///     1、对于每个子树的头结点来说，它的左树都比它小，右树都比他大
        ///     2、一颗经典的二叉树内，可以认为它是没有重复值的
        /// 2、如何判断搜索二叉树：
        ///     1、对树中序遍历
        ///     2、结果是升序的，为搜索二叉树，只要有一个降序，就不是
        ///  
        public static int preValue = int.MinValue;//记录上一个最小值
        public static bool IsBST(TreeNode head)
        {
            
            if (head == null) return true;//空树认为是搜索二叉树

            ///代码解释
            /// 先判断左树是否是搜索二叉树
            /// 如果左树不是二叉树，整棵树都不是
            /// 左树是二叉树的情况，再和该左树的根节点的值进行比较，如果小于根节点的值，说明包括根节点在内都满足搜索二叉树
            bool isLeftBST = IsBST(head.left);
            if(!isLeftBST) 
                return false;
            if (head.value <= preValue)
                return false;
            else
                preValue = head.value;

            ///代码解释
            /// 代码走到这里，说明左树都是搜索二叉树，如果右树也是搜索二叉树，那么一整棵树都是搜索二叉树
            return IsBST(head.right);
        }

        ///如何判断一颗二叉树是完全二叉树：
        /// 1、什么是完全二叉树：
        ///     ————如果一颗二叉树要么某一层是满的，如果有不满的层，那不满的层是最后一层
        ///     ————即使最后一层不满，那它的样子也是从左到右依次遍满的样子
        /// 2、怎么判断一棵树是否是完全二叉树？
        ///     ————使用宽度优先遍历
        ///     ————如果一个结点只有右孩子、没有左孩子，那它一定不是完全二叉树（无法从左到右依次遍满）
        ///     ————满足上述条件下，如果遇到第一个左右孩子不双全的结点，那么接下来遇到的结点都必须是叶节点
        ///     
        public static bool isCBT(TreeNode head)
        {
            if(head == null) return true;//如果树为空，认为它是完全二叉树

            ///代码解释：
            /// 准备一个队列用来做宽度优先遍历
            /// 准备两个指针变量，用来判断左孩子和右孩子是否为空，如果一个结点只有右孩子没有左孩子，那他一定不是完全二叉树
            /// 准备一个布尔变量，在遇到一个第一个只有左孩子没有右孩子的结点时，变为 true
            /// 注意，只要 leaf 是 true，接下来每个结点都必须是叶节点
            Queue<TreeNode> queue = new();
            queue.Enqueue(head);
            bool leaf = false;
            TreeNode left = null;
            TreeNode right = null;

            while(queue.Count > 0)
            {
                head = queue.Dequeue();
                left = head.left;
                right = head.right;

                ///代码解释：
                /// 第一个条件：
                ///     --如果左孩子为空而右孩子不为空， 一定不是完全二叉树
                /// 第二个条件：
                ///     --如果 leaf 为 true，表示上一个结点是一个左右不双全的结点，那么接下来的每个结点包括当前结点 head 本身
                ///     --都必须是叶节点，如果有一个存在孩子，都表明不是完全二叉树
                /// 
                if((left == null && right != null) || (leaf && (left != null || right != null)))
                    return false;                                                         
                if(left != null)//宽度优先遍历：在队列中先进先出，所以需要先头再左再右
                    queue.Enqueue(left);
                if(right != null)
                    queue.Enqueue(right);
                else//只要右孩子为空（左孩子不管为不为空不管），那么接下来遇到的每个结点都必须是叶节点
                    leaf = true;
            }

            //如果代码走到这里，宽度优先遍历完成且满足完全二叉树的条件，返回true
            return true;
        }

        ///如何判断一颗二叉树是满二叉树：
        /// 1、什么是满二叉树：
        ///     ————除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。
        /// 2、比较麻烦的做法：
        ///     1、算出树的最大深度
        ///     2、算出树的结点个数
        ///     3、最大深度与结点个数满足：N = 2^l - 1（其中 N 是结点个数，l 是最大深度），则这棵树必是满二叉树
        /// 3、使用递归套路

        ///如何判断一颗二叉树是平衡二叉树：
        /// 1、什么是平衡二叉树？
        ///     ————对任何一个子树来说，它的左树和右树的高度差都不超过 1
        /// 2、如何判断一棵树是平衡二叉树

        ///套路解题：判断搜索二叉树、满二叉树和平衡二叉树都可以使用套路来做
        /// ————二叉树的递归套路：向左树和右树收集信息
        /// ————代码见 RecursiveRoutine 类

        /*static void Main(string[] args)
        {
            Console.WriteLine("------------");
            Console.WriteLine("------------");
        }*/
    }
}
